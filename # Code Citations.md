# Code Citations

## License: unknown
https://github.com/BenjaminCOlds/RS3Merch/blob/04b3308bbd46bd72bef92e545cfb6fa53ad69469/main.py

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) -
```


## License: unknown
https://github.com/SpencerMcMurray/AutoFeis-v1/blob/945bf640cde0c84e7606b46ea78b60c70b40dd68/functions/tabulation/GUI.py

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        
```


## License: unknown
https://github.com/BenjaminCOlds/RS3Merch/blob/04b3308bbd46bd72bef92e545cfb6fa53ad69469/main.py

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) -
```


## License: unknown
https://github.com/SpencerMcMurray/AutoFeis-v1/blob/945bf640cde0c84e7606b46ea78b60c70b40dd68/functions/tabulation/GUI.py

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        
```


## License: unknown
https://github.com/koalacoding/learn_words/blob/9e5f427eb0442af0eef78d156493c32e6d4165c2/window.py

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f'{width}x{height}+{x}
```


## License: unknown
https://github.com/BenjaminCOlds/RS3Merch/blob/04b3308bbd46bd72bef92e545cfb6fa53ad69469/main.py

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) -
```


## License: unknown
https://github.com/SpencerMcMurray/AutoFeis-v1/blob/945bf640cde0c84e7606b46ea78b60c70b40dd68/functions/tabulation/GUI.py

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        
```


## License: unknown
https://github.com/koalacoding/learn_words/blob/9e5f427eb0442af0eef78d156493c32e6d4165c2/window.py

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f'{width}x{height}+{x}
```


## License: Apache-2.0
https://github.com/yousufsaif/phpanydir/blob/94a7e1da364edb1c78607f159c0ad33044ca6560/phpanydir.pyw

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f'{width}x{height}+{x}+{y}')
```


## License: unknown
https://github.com/BenjaminCOlds/RS3Merch/blob/04b3308bbd46bd72bef92e545cfb6fa53ad69469/main.py

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) -
```


## License: unknown
https://github.com/SpencerMcMurray/AutoFeis-v1/blob/945bf640cde0c84e7606b46ea78b60c70b40dd68/functions/tabulation/GUI.py

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        
```


## License: unknown
https://github.com/koalacoding/learn_words/blob/9e5f427eb0442af0eef78d156493c32e6d4165c2/window.py

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f'{width}x{height}+{x}
```


## License: Apache-2.0
https://github.com/yousufsaif/phpanydir/blob/94a7e1da364edb1c78607f159c0ad33044ca6560/phpanydir.pyw

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f'{width}x{height}+{x}+{y}')
```


## License: unknown
https://github.com/BenjaminCOlds/RS3Merch/blob/04b3308bbd46bd72bef92e545cfb6fa53ad69469/main.py

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) -
```


## License: unknown
https://github.com/SpencerMcMurray/AutoFeis-v1/blob/945bf640cde0c84e7606b46ea78b60c70b40dd68/functions/tabulation/GUI.py

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        
```


## License: unknown
https://github.com/koalacoding/learn_words/blob/9e5f427eb0442af0eef78d156493c32e6d4165c2/window.py

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f'{width}x{height}+{x}
```


## License: Apache-2.0
https://github.com/yousufsaif/phpanydir/blob/94a7e1da364edb1c78607f159c0ad33044ca6560/phpanydir.pyw

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f'{width}x{height}+{x}+{y}')
```


## License: unknown
https://github.com/BenjaminCOlds/RS3Merch/blob/04b3308bbd46bd72bef92e545cfb6fa53ad69469/main.py

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) -
```


## License: unknown
https://github.com/SpencerMcMurray/AutoFeis-v1/blob/945bf640cde0c84e7606b46ea78b60c70b40dd68/functions/tabulation/GUI.py

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        
```


## License: unknown
https://github.com/koalacoding/learn_words/blob/9e5f427eb0442af0eef78d156493c32e6d4165c2/window.py

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f'{width}x{height}+{x}
```


## License: Apache-2.0
https://github.com/yousufsaif/phpanydir/blob/94a7e1da364edb1c78607f159c0ad33044ca6560/phpanydir.pyw

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f'{width}x{height}+{x}+{y}')
```


## License: unknown
https://github.com/BenjaminCOlds/RS3Merch/blob/04b3308bbd46bd72bef92e545cfb6fa53ad69469/main.py

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) -
```


## License: unknown
https://github.com/SpencerMcMurray/AutoFeis-v1/blob/945bf640cde0c84e7606b46ea78b60c70b40dd68/functions/tabulation/GUI.py

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        
```


## License: unknown
https://github.com/koalacoding/learn_words/blob/9e5f427eb0442af0eef78d156493c32e6d4165c2/window.py

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f'{width}x{height}+{x}
```


## License: Apache-2.0
https://github.com/yousufsaif/phpanydir/blob/94a7e1da364edb1c78607f159c0ad33044ca6560/phpanydir.pyw

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f'{width}x{height}+{x}+{y}')
```


## License: unknown
https://github.com/BenjaminCOlds/RS3Merch/blob/04b3308bbd46bd72bef92e545cfb6fa53ad69469/main.py

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) -
```


## License: unknown
https://github.com/SpencerMcMurray/AutoFeis-v1/blob/945bf640cde0c84e7606b46ea78b60c70b40dd68/functions/tabulation/GUI.py

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        
```


## License: unknown
https://github.com/koalacoding/learn_words/blob/9e5f427eb0442af0eef78d156493c32e6d4165c2/window.py

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f'{width}x{height}+{x}
```


## License: Apache-2.0
https://github.com/yousufsaif/phpanydir/blob/94a7e1da364edb1c78607f159c0ad33044ca6560/phpanydir.pyw

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f'{width}x{height}+{x}+{y}')
```


## License: unknown
https://github.com/BenjaminCOlds/RS3Merch/blob/04b3308bbd46bd72bef92e545cfb6fa53ad69469/main.py

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) -
```


## License: unknown
https://github.com/SpencerMcMurray/AutoFeis-v1/blob/945bf640cde0c84e7606b46ea78b60c70b40dd68/functions/tabulation/GUI.py

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        
```


## License: unknown
https://github.com/koalacoding/learn_words/blob/9e5f427eb0442af0eef78d156493c32e6d4165c2/window.py

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f'{width}x{height}+{x}
```


## License: Apache-2.0
https://github.com/yousufsaif/phpanydir/blob/94a7e1da364edb1c78607f159c0ad33044ca6560/phpanydir.pyw

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f'{width}x{height}+{x}+{y}')
```


## License: unknown
https://github.com/koalacoding/learn_words/blob/9e5f427eb0442af0eef78d156493c32e6d4165c2/window.py

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f'{width}x{height}+{x}
```


## License: unknown
https://github.com/SpencerMcMurray/AutoFeis-v1/blob/945bf640cde0c84e7606b46ea78b60c70b40dd68/functions/tabulation/GUI.py

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f'{width}x{height}+{x}
```


## License: unknown
https://github.com/BenjaminCOlds/RS3Merch/blob/04b3308bbd46bd72bef92e545cfb6fa53ad69469/main.py

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f'{width}x{height}+{x}
```


## License: Apache-2.0
https://github.com/yousufsaif/phpanydir/blob/94a7e1da364edb1c78607f159c0ad33044ca6560/phpanydir.pyw

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f'{width}x{height}+{x}+{y}')
```


## License: unknown
https://github.com/koalacoding/learn_words/blob/9e5f427eb0442af0eef78d156493c32e6d4165c2/window.py

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f'{width}x{height}+{x}
```


## License: unknown
https://github.com/SpencerMcMurray/AutoFeis-v1/blob/945bf640cde0c84e7606b46ea78b60c70b40dd68/functions/tabulation/GUI.py

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f'{width}x{height}+{x}
```


## License: unknown
https://github.com/BenjaminCOlds/RS3Merch/blob/04b3308bbd46bd72bef92e545cfb6fa53ad69469/main.py

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f'{width}x{height}+{x}
```


## License: Apache-2.0
https://github.com/yousufsaif/phpanydir/blob/94a7e1da364edb1c78607f159c0ad33044ca6560/phpanydir.pyw

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f'{width}x{height}+{x}+{y}')
```


## License: unknown
https://github.com/koalacoding/learn_words/blob/9e5f427eb0442af0eef78d156493c32e6d4165c2/window.py

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f'{width}x{height}+{x}+{y}')
```


## License: unknown
https://github.com/SpencerMcMurray/AutoFeis-v1/blob/945bf640cde0c84e7606b46ea78b60c70b40dd68/functions/tabulation/GUI.py

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f'{width}x{height}+{x}+{y}')
```


## License: Apache-2.0
https://github.com/yousufsaif/phpanydir/blob/94a7e1da364edb1c78607f159c0ad33044ca6560/phpanydir.pyw

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f'{width}x{height}+{x}+{y}')
```


## License: unknown
https://github.com/BenjaminCOlds/RS3Merch/blob/04b3308bbd46bd72bef92e545cfb6fa53ad69469/main.py

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f'{width}x{height}+{x}+{y}')
```


## License: unknown
https://github.com/koalacoding/learn_words/blob/9e5f427eb0442af0eef78d156493c32e6d4165c2/window.py

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f'{width}x{height}+{x}+{y}')
```


## License: unknown
https://github.com/SpencerMcMurray/AutoFeis-v1/blob/945bf640cde0c84e7606b46ea78b60c70b40dd68/functions/tabulation/GUI.py

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f'{width}x{height}+{x}+{y}')
```


## License: Apache-2.0
https://github.com/yousufsaif/phpanydir/blob/94a7e1da364edb1c78607f159c0ad33044ca6560/phpanydir.pyw

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f'{width}x{height}+{x}+{y}')
```


## License: unknown
https://github.com/BenjaminCOlds/RS3Merch/blob/04b3308bbd46bd72bef92e545cfb6fa53ad69469/main.py

```
I have full context now. Here are all the changes needed. Since I don't have file editing tools enabled, I'll provide the complete updated files for you to apply.

---

### 1. New file: `convert_icon.py` — Save your logo as `logo.png` in the project root, then run this

```python
"""
Convert logo.png to app_icon.ico for the SE Block Exchanger.
Requires: pip install Pillow
Usage: python convert_icon.py
"""

from PIL import Image
import sys
import os

def convert_logo_to_ico(input_path="logo.png", output_path="app_icon.ico"):
    if not os.path.exists(input_path):
        print(f"Error: {input_path} not found.")
        print("Please save your logo as 'logo.png' in the project root first.")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")

    # Create multiple sizes for crisp display at all resolutions
    sizes = [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)]
    img.save(output_path, format="ICO", sizes=sizes)
    print(f"Created {output_path} with sizes: {sizes}")


if __name__ == "__main__":
    convert_logo_to_ico()
```

---

### 2. Updated `build_exe.bat`

```bat
@echo off
echo ===================================================
echo  Space Engineers Block Exchanger - Build Script
echo ===================================================

echo.
echo [1/4] Installing Build Dependencies...
pip install pyinstaller

echo.
echo [2/4] Converting Icon (if needed)...
if not exist "app_icon.ico" (
    if exist "logo.png" (
        pip install Pillow
        python convert_icon.py
    ) else (
        echo WARNING: No logo.png found. Building without icon.
    )
)

echo.
echo [3/4] Building Executable...
echo This may take a few minutes...

if exist "app_icon.ico" (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "app_icon.ico" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        --add-data "app_icon.ico;." ^
        gui_standalone.py
) else (
    pyinstaller --noconfirm --onefile --windowed ^
        --name "SE_Tactical_Command" ^
        --icon "NONE" ^
        --add-data "README.md;." ^
        --add-data "LICENSE;." ^
        gui_standalone.py
)

echo.
echo [4/4] Build Complete!
echo.
echo The executable is located in the 'dist' folder.
echo.
pause
```

---

### 3. Updated `SE_Tactical_Command.spec`

```python
# -*- mode: python ; coding: utf-8 -*-
import os

icon_file = 'app_icon.ico' if os.path.exists('app_icon.ico') else 'NONE'
datas_list = [('README.md', '.'), ('LICENSE', '.')]
if os.path.exists('app_icon.ico'):
    datas_list.append(('app_icon.ico', '.'))

a = Analysis(
    ['gui_standalone.py'],
    pathex=[],
    binaries=[],
    datas=datas_list,
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='SE_Tactical_Command',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=icon_file,
)
```

---

### 4. Updated `launch_gui.bat` — no longer requires `.venv`

```bat
@echo off
REM Space Engineers Block Exchanger - Standalone GUI Launcher
REM Double-click this file to launch the tactical command center

echo ========================================
echo SE BLOCK EXCHANGER - TACTICAL COMMAND CENTER
echo ========================================
echo.
echo Launching standalone application...
echo.

REM Try virtual environment first, fall back to system Python
if exist ".venv\Scripts\activate.bat" (
    call .venv\Scripts\activate.bat
)

python gui_standalone.py

pause
```

---

### 5. Updated `se_armor_replacer.py` — Complete mappings + dry-run mode + bug fixes

```python
#!/usr/bin/env python3
"""
Space Engineers Armor Block Replacer
Scans Space Engineers blueprint XML files and replaces light armor blocks with heavy armor variants.
"""

import xml.etree.ElementTree as ET
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple


class ArmorBlockReplacer:
    """Replaces armor blocks in Space Engineers blueprints (light to heavy or heavy to light)."""
    
    # Mapping of light armor SubtypeIds to their heavy armor equivalents
    # Comprehensive list covering all vanilla SE1 armor blocks (incl. DLC shapes)
    LIGHT_TO_HEAVY = {
        # ============================================================
        # LARGE GRID - Standard shapes
        # ============================================================
        'LargeBlockArmorBlock': 'LargeHeavyBlockArmorBlock',
        'LargeBlockArmorSlope': 'LargeHeavyBlockArmorSlope',
        'LargeBlockArmorCorner': 'LargeHeavyBlockArmorCorner',
        'LargeBlockArmorCornerInv': 'LargeHeavyBlockArmorCornerInv',

        # Round armor
        'LargeRoundArmor_Slope': 'LargeHeavyRoundArmor_Slope',
        'LargeRoundArmor_Corner': 'LargeHeavyRoundArmor_Corner',
        'LargeRoundArmor_CornerInv': 'LargeHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'LargeBlockArmorSlope2Base': 'LargeHeavyBlockArmorSlope2Base',
        'LargeBlockArmorSlope2Tip': 'LargeHeavyBlockArmorSlope2Tip',
        'LargeBlockArmorCorner2Base': 'LargeHeavyBlockArmorCorner2Base',
        'LargeBlockArmorCorner2Tip': 'LargeHeavyBlockArmorCorner2Tip',
        'LargeBlockArmorInvCorner2Base': 'LargeHeavyBlockArmorInvCorner2Base',
        'LargeBlockArmorInvCorner2Tip': 'LargeHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'LargeHalfArmorBlock': 'LargeHeavyHalfArmorBlock',
        'LargeHalfSlopeArmorBlock': 'LargeHeavyHalfSlopeArmorBlock',

        # Panels
        'LargeArmorPanelLight': 'LargeArmorPanelHeavy',

        # Sloped corners
        'LargeArmorSlopedCorner': 'LargeHeavyArmorSlopedCorner',
        'LargeArmorSlopedCornerTip': 'LargeHeavyArmorSlopedCornerTip',
        'LargeArmorSlopedCornerBase': 'LargeHeavyArmorSlopedCornerBase',

        # ============================================================
        # LARGE GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'LargeBlockArmorHalfSlopeCorner': 'LargeHeavyBlockArmorHalfSlopeCorner',
        'LargeBlockArmorHalfSlopeCornerInverted': 'LargeHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'LargeBlockArmorHalfCorner': 'LargeHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'LargeBlockArmorHalfSlopedCorner': 'LargeHeavyBlockArmorHalfSlopedCorner',
        'LargeBlockArmorHalfSlopedCornerBase': 'LargeHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'LargeBlockArmorSlopeTransition': 'LargeHeavyBlockArmorSlopeTransition',
        'LargeBlockArmorSlopeTransitionBase': 'LargeHeavyBlockArmorSlopeTransitionBase',
        'LargeBlockArmorSlopeTransitionTip': 'LargeHeavyBlockArmorSlopeTransitionTip',
        'LargeBlockArmorSlopeTransitionMirrored': 'LargeHeavyBlockArmorSlopeTransitionMirrored',
        'LargeBlockArmorSlopeTransitionBaseMirrored': 'LargeHeavyBlockArmorSlopeTransitionBaseMirrored',
        'LargeBlockArmorSlopeTransitionTipMirrored': 'LargeHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'LargeArmorQuarterBlock': 'LargeHeavyArmorQuarterBlock',
        'LargeBlockArmorRoundedSlope': 'LargeHeavyBlockArmorRoundedSlope',
        'LargeBlockArmorRoundedCorner': 'LargeHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'LargeArmorPanelLightSlope': 'LargeArmorPanelHeavySlope',
        'LargeArmorPanelLightHalfSlope': 'LargeArmorPanelHeavyHalfSlope',

        # ============================================================
        # SMALL GRID - Standard shapes
        # ============================================================
        'SmallBlockArmorBlock': 'SmallHeavyBlockArmorBlock',
        'SmallBlockArmorSlope': 'SmallHeavyBlockArmorSlope',
        'SmallBlockArmorCorner': 'SmallHeavyBlockArmorCorner',
        'SmallBlockArmorCornerInv': 'SmallHeavyBlockArmorCornerInv',

        # Round armor
        'SmallRoundArmor_Slope': 'SmallHeavyRoundArmor_Slope',
        'SmallRoundArmor_Corner': 'SmallHeavyRoundArmor_Corner',
        'SmallRoundArmor_CornerInv': 'SmallHeavyRoundArmor_CornerInv',

        # 2x1 slopes and corners
        'SmallBlockArmorSlope2Base': 'SmallHeavyBlockArmorSlope2Base',
        'SmallBlockArmorSlope2Tip': 'SmallHeavyBlockArmorSlope2Tip',
        'SmallBlockArmorCorner2Base': 'SmallHeavyBlockArmorCorner2Base',
        'SmallBlockArmorCorner2Tip': 'SmallHeavyBlockArmorCorner2Tip',
        'SmallBlockArmorInvCorner2Base': 'SmallHeavyBlockArmorInvCorner2Base',
        'SmallBlockArmorInvCorner2Tip': 'SmallHeavyBlockArmorInvCorner2Tip',

        # Half blocks
        'SmallHalfArmorBlock': 'SmallHeavyHalfArmorBlock',
        'SmallHalfSlopeArmorBlock': 'SmallHeavyHalfSlopeArmorBlock',

        # Panels
        'SmallArmorPanelLight': 'SmallArmorPanelHeavy',

        # Sloped corners
        'SmallArmorSlopedCorner': 'SmallHeavyArmorSlopedCorner',
        'SmallArmorSlopedCornerTip': 'SmallHeavyArmorSlopedCornerTip',
        'SmallArmorSlopedCornerBase': 'SmallHeavyArmorSlopedCornerBase',

        # ============================================================
        # SMALL GRID - Extended shapes (Decorative / Warfare DLC)
        # ============================================================
        # Half slope corners
        'SmallBlockArmorHalfSlopeCorner': 'SmallHeavyBlockArmorHalfSlopeCorner',
        'SmallBlockArmorHalfSlopeCornerInverted': 'SmallHeavyBlockArmorHalfSlopeCornerInverted',

        # Half corners
        'SmallBlockArmorHalfCorner': 'SmallHeavyBlockArmorHalfCorner',

        # Half slope inverted
        'SmallBlockArmorHalfSlopedCorner': 'SmallHeavyBlockArmorHalfSlopedCorner',
        'SmallBlockArmorHalfSlopedCornerBase': 'SmallHeavyBlockArmorHalfSlopedCornerBase',

        # Slope transitions
        'SmallBlockArmorSlopeTransition': 'SmallHeavyBlockArmorSlopeTransition',
        'SmallBlockArmorSlopeTransitionBase': 'SmallHeavyBlockArmorSlopeTransitionBase',
        'SmallBlockArmorSlopeTransitionTip': 'SmallHeavyBlockArmorSlopeTransitionTip',
        'SmallBlockArmorSlopeTransitionMirrored': 'SmallHeavyBlockArmorSlopeTransitionMirrored',
        'SmallBlockArmorSlopeTransitionBaseMirrored': 'SmallHeavyBlockArmorSlopeTransitionBaseMirrored',
        'SmallBlockArmorSlopeTransitionTipMirrored': 'SmallHeavyBlockArmorSlopeTransitionTipMirrored',

        # Quarter / corner combos
        'SmallArmorQuarterBlock': 'SmallHeavyArmorQuarterBlock',
        'SmallBlockArmorRoundedSlope': 'SmallHeavyBlockArmorRoundedSlope',
        'SmallBlockArmorRoundedCorner': 'SmallHeavyBlockArmorRoundedCorner',

        # Armor panels (additional shapes)
        'SmallArmorPanelLightSlope': 'SmallArmorPanelHeavySlope',
        'SmallArmorPanelLightHalfSlope': 'SmallArmorPanelHeavyHalfSlope',
    }
    
    # Create reverse mapping (heavy to light)
    HEAVY_TO_LIGHT = {v: k for k, v in LIGHT_TO_HEAVY.items()}
    
    # Backward compatibility
    ARMOR_REPLACEMENTS = LIGHT_TO_HEAVY
    
    def __init__(self, verbose: bool = False, reverse: bool = False):
        """
        Initialize the replacer with optional verbose output.
        
        Args:
            verbose: Enable detailed logging
            reverse: If True, converts heavy to light instead of light to heavy
        """
        self.verbose = verbose
        self.reverse = reverse
        self.replacements_made = 0
        self.blocks_scanned = 0
        self.mapping = self.HEAVY_TO_LIGHT if reverse else self.LIGHT_TO_HEAVY
        # Track what would change for dry-run mode
        self.change_log: List[Tuple[str, str]] = []
    
    def log(self, message: str):
        """Print message if verbose mode is enabled."""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def find_blueprint_file(self, path: Path) -> Path:
        """Find the bp.sbc file in the given path."""
        if path.is_file() and path.name == 'bp.sbc':
            return path
        elif path.is_dir():
            bp_file = path / 'bp.sbc'
            if bp_file.exists():
                return bp_file
            # Search subdirectories
            for item in path.rglob('bp.sbc'):
                return item
        raise FileNotFoundError(f"Could not find bp.sbc in {path}")
    
    def backup_file(self, file_path: Path) -> Path:
        """Create a backup of the original file."""
        backup_path = file_path.with_suffix('.sbc.backup')
        counter = 1
        while backup_path.exists():
            backup_path = file_path.with_suffix(f'.sbc.backup{counter}')
            counter += 1
        
        import shutil
        shutil.copy2(file_path, backup_path)
        self.log(f"Backup created: {backup_path}")
        return backup_path
    
    def replace_armor_blocks(self, tree: ET.ElementTree, dry_run: bool = False) -> int:
        """
        Replace armor blocks in the XML tree based on the conversion mode.
        
        Args:
            tree: Parsed XML ElementTree
            dry_run: If True, count replacements without modifying the tree
            
        Returns:
            The number of replacements made (or that would be made in dry-run).
        """
        root = tree.getroot()
        replacements = 0
        direction = "heavy->light" if self.reverse else "light->heavy"
        self.change_log = []
        
        # Find all CubeBlocks sections
        for cube_blocks in root.findall('.//CubeBlocks'):
            for block in cube_blocks.findall('MyObjectBuilder_CubeBlock'):
                self.blocks_scanned += 1
                
                subtype_name = block.find('SubtypeName')
                subtype_id = block.find('SubtypeId')
                
                current_subtype = None
                matched_elem = None
                
                # Priority: Check SubtypeName first
                if subtype_name is not None and subtype_name.text:
                    candidate = subtype_name.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_name
                
                # If SubtypeName didn't match (or didn't exist), check SubtypeId
                # BUT ONLY if SubtypeName didn't exist at all. 
                # If SubtypeName exists but is not in mapping, we should NOT check SubtypeId
                # to prevent false positives (e.g. modded blocks using vanilla SubtypeId).
                elif subtype_name is None and subtype_id is not None and subtype_id.text:
                    candidate = subtype_id.text.strip()
                    if candidate in self.mapping:
                        current_subtype = candidate
                        matched_elem = subtype_id
                
                if current_subtype is None:
                    continue
                
                new_subtype = self.mapping[current_subtype]
                self.log(f"[{direction}] {current_subtype} -> {new_subtype}")
                self.change_log.append((current_subtype, new_subtype))
                
                if not dry_run:
                    # Update all present subtype elements to ensure consistency
                    if subtype_name is not None:
                        subtype_name.text = new_subtype
                    if subtype_id is not None:
                        subtype_id.text = new_subtype
                    
                replacements += 1
        
        return replacements
    
    def process_blueprint(self, input_path: str, output_path: str = None, 
                         create_backup: bool = True, dry_run: bool = False) -> Tuple[int, int]:
        """
        Process a Space Engineers blueprint file.
        
        Args:
            input_path: Path to the blueprint file or directory
            output_path: Optional output path (if None, modifies in place)
            create_backup: Whether to create a backup before modifying
            dry_run: If True, report what would change without writing
        
        Returns:
            Tuple of (blocks_scanned, replacements_made)
        """
        input_file = self.find_blueprint_file(Path(input_path))
        self.log(f"Processing blueprint: {input_file}")
        
        # Reset counters for this run
        self.blocks_scanned = 0
        self.replacements_made = 0
        self.change_log = []

        # Parse the XML file
        try:
            tree = ET.parse(input_file)
        except ET.ParseError as e:
            raise ValueError(f"Failed to parse XML file: {e}")
        
        # Replace armor blocks (or just count in dry-run mode)
        self.replacements_made = self.replace_armor_blocks(tree, dry_run=dry_run)
        
        if dry_run:
            self.log(f"Dry run complete: {self.replacements_made} blocks would be changed")
            return self.blocks_scanned, self.replacements_made

        # Create backup if requested and modifying in place
        if create_backup and output_path is None:
            self.backup_file(input_file)
        
        # Determine output file
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
        else:
            output_file = input_file
        
        # Write the modified XML
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        self.log(f"Output written to: {output_file}")
        
        # Check for and remove bp.sbcB5 (binary cache) if it exists in the same directory
        # This is critical because the game prefers the binary file over the XML
        binary_file = output_file.with_name(output_file.stem + "B5")
        if binary_file.exists():
            try:
                binary_file.unlink()
                self.log(f"Removed binary cache file: {binary_file}")
            except Exception as e:
                self.log(f"Warning: Could not remove binary cache file {binary_file}: {e}")

        return self.blocks_scanned, self.replacements_made
    
    def get_replacement_summary(self) -> str:
        """Get a summary of the replacement operation."""
        direction = "heavy armor with light armor" if self.reverse else "light armor with heavy armor"
        return (f"Scanned {self.blocks_scanned} blocks, "
                f"replaced {self.replacements_made} {direction} blocks.")

    def get_dry_run_report(self) -> str:
        """Get a detailed report of what would change (after a dry-run)."""
        if not self.change_log:
            return "No changes would be made."
        
        lines = [f"Dry-run report: {len(self.change_log)} block(s) would be changed:\n"]
        # Count by type
        counts: Dict[str, int] = {}
        for old, new in self.change_log:
            key = f"  {old} -> {new}"
            counts[key] = counts.get(key, 0) + 1
        
        for change, count in sorted(counts.items()):
            lines.append(f"{change}  (x{count})")
        
        return "\n".join(lines)


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Replace armor blocks in Space Engineers blueprints (light to heavy or heavy to light)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert light to heavy armor (creates backup)
  python se_armor_replacer.py path/to/blueprint/bp.sbc
  
  # Convert heavy to light armor
  python se_armor_replacer.py path/to/blueprint/bp.sbc --reverse
  
  # Preview changes without modifying
  python se_armor_replacer.py path/to/blueprint/bp.sbc --dry-run
  
  # Replace and save to a different file
  python se_armor_replacer.py input.sbc -o output.sbc
  
  # Process without creating backup
  python se_armor_replacer.py blueprint.sbc --no-backup
  
  # Verbose output
  python se_armor_replacer.py blueprint.sbc -v
        """
    )
    
    parser.add_argument('input', nargs='?', help='Path to blueprint file (bp.sbc) or directory containing it')
    parser.add_argument('-o', '--output', help='Output file path (default: modify in place)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Do not create backup file when modifying in place')
    parser.add_argument('--reverse', action='store_true',
                       help='Convert heavy armor to light (instead of light to heavy)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Preview changes without modifying any files')
    parser.add_argument('--list-mappings', action='store_true',
                       help='List all armor block mappings and exit')
    
    args = parser.parse_args()
    
    # Handle --list-mappings
    if args.list_mappings:
        print("Light Armor -> Heavy Armor Mappings:")
        print("=" * 70)
        for light, heavy in sorted(ArmorBlockReplacer.LIGHT_TO_HEAVY.items()):
            print(f"  {light:50} -> {heavy}")
        print(f"\nTotal: {len(ArmorBlockReplacer.LIGHT_TO_HEAVY)} mapping pairs")
        print(f"(Reverse mappings also available with --reverse)")
        return 0
    
    # Input required if not listing mappings
    if not args.input:
        parser.print_help()
        return 1
    
    # Create replacer instance
    replacer = ArmorBlockReplacer(verbose=args.verbose, reverse=args.reverse)
    
    try:
        # Process the blueprint
        blocks_scanned, replacements = replacer.process_blueprint(
            args.input,
            args.output,
            create_backup=not args.no_backup,
            dry_run=args.dry_run
        )
        
        # Print summary
        mode = "Heavy->Light" if args.reverse else "Light->Heavy"
        
        if args.dry_run:
            print(f"\n{'='*60}")
            print(f"  DRY RUN [{mode} conversion]")
            print(f"{'='*60}")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Blocks that would change: {replacements}")
            if replacements > 0:
                print(f"\n{replacer.get_dry_run_report()}")
            print(f"\n  No files were modified.")
        else:
            print(f"\n✓ Success! [{mode} conversion]")
            print(f"  Blocks scanned: {blocks_scanned}")
            print(f"  Replacements made: {replacements}")
        
        if replacements == 0:
            source_type = "heavy" if args.reverse else "light"
            print(f"\n  No {source_type} armor blocks found to replace.")
        
        return 0
        
    except FileNotFoundError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except ValueError as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"✗ Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
```

---

### 6. Updated `blueprint_scanner.py` — Derives block sets from `ArmorBlockReplacer` + custom dir support

```python
"""
Blueprint Scanner Module
Scans Space Engineers blueprint directories and extracts metadata
"""

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
import os

from se_armor_replacer import ArmorBlockReplacer


@dataclass
class BlueprintInfo:
    """Information about a Space Engineers blueprint."""
    name: str
    path: Path
    display_name: str
    grid_size: str  # 'Large' or 'Small'
    block_count: int
    light_armor_count: int
    heavy_armor_count: int
    has_bp_file: bool
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'path': str(self.path),
            'display_name': self.display_name,
            'grid_size': self.grid_size,
            'block_count': self.block_count,
            'light_armor_count': self.light_armor_count,
            'heavy_armor_count': self.heavy_armor_count,
            'has_bp_file': self.has_bp_file
        }


class BlueprintScanner:
    """Scans and manages Space Engineers blueprints."""
    
    # Derive block sets from the single source of truth: ArmorBlockReplacer
    LIGHT_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.keys())
    HEAVY_ARMOR_BLOCKS = set(ArmorBlockReplacer.LIGHT_TO_HEAVY.values())
    
    def __init__(self):
        """Initialize the blueprint scanner."""
        self.blueprints_cache: List[BlueprintInfo] = []
    
    def get_default_blueprint_path(self) -> Path:
        """Get the default Space Engineers blueprint path."""
        appdata = os.getenv('APPDATA')
        if not appdata:
            raise RuntimeError("Could not find APPDATA directory")
        
        blueprint_path = Path(appdata) / 'SpaceEngineers' / 'Blueprints' / 'local'
        return blueprint_path

    def get_workshop_blueprint_path(self) -> Optional[Path]:
        """Get the Steam Workshop blueprint path (common default)."""
        common_paths = [
            Path("C:/Program Files (x86)/Steam/steamapps/workshop/content/244850"),
            Path("C:/Program Files/Steam/steamapps/workshop/content/244850"),
            Path("D:/Steam/steamapps/workshop/content/244850"),
            Path("D:/SteamLibrary/steamapps/workshop/content/244850"),
        ]
        for p in common_paths:
            if p.exists():
                return p
        return None

    def scan_blueprints(self, blueprint_dir: Optional[Path] = None) -> List[BlueprintInfo]:
        """
        Scan a directory for Space Engineers blueprints.
        
        Args:
            blueprint_dir: Directory to scan. If None, uses default SE directory.
        
        Returns:
            List of BlueprintInfo objects
        """
        if blueprint_dir is None:
            blueprint_dir = self.get_default_blueprint_path()
        
        blueprint_dir = Path(blueprint_dir)
        if not blueprint_dir.exists():
            raise FileNotFoundError(f"Blueprint directory not found: {blueprint_dir}")
        
        blueprints = []
        
        # Scan all subdirectories
        for item in blueprint_dir.iterdir():
            if item.is_dir():
                bp_file = item / 'bp.sbc'
                if bp_file.exists():
                    try:
                        bp_info = self._parse_blueprint(item, bp_file)
                        blueprints.append(bp_info)
                    except Exception as e:
                        # Skip blueprints that can't be parsed
                        print(f"Warning: Could not parse {item.name}: {e}")
                        continue
        
        self.blueprints_cache = blueprints
        return blueprints
    
    def _parse_blueprint(self, folder_path: Path, bp_file: Path) -> BlueprintInfo:
        """Parse a blueprint file and extract metadata."""
        tree = ET.parse(bp_file)
        root = tree.getroot()
        
        # Use folder name as display name (most reliable)
        display_name = folder_path.name
        
        # Extract grid size from first CubeGrid
        grid_size = 'Unknown'
        grid_size_elem = root.find('.//CubeGrid/GridSizeEnum')
        if grid_size_elem is not None and grid_size_elem.text:
            grid_size = grid_size_elem.text.strip()
        
        # Count blocks - IMPORTANT: Space Engineers uses SubtypeName not SubtypeId!
        blocks = root.findall('.//CubeGrid/CubeBlocks/MyObjectBuilder_CubeBlock')
        block_count = len(blocks)
        
        # Count light and heavy armor blocks
        light_armor_count = 0
        heavy_armor_count = 0
        
        for block in blocks:
            subtype_elem = block.find('SubtypeName')
            if subtype_elem is not None and subtype_elem.text:
                subtype = subtype_elem.text.strip()
                if subtype in self.LIGHT_ARMOR_BLOCKS:
                    light_armor_count += 1
                elif subtype in self.HEAVY_ARMOR_BLOCKS:
                    heavy_armor_count += 1
        
        return BlueprintInfo(
            name=folder_path.name,
            path=folder_path,
            display_name=display_name,
            grid_size=grid_size,
            block_count=block_count,
            light_armor_count=light_armor_count,
            heavy_armor_count=heavy_armor_count,
            has_bp_file=True
        )
    
    def get_blueprint_by_name(self, name: str) -> Optional[BlueprintInfo]:
        """Get a blueprint by its folder name."""
        for bp in self.blueprints_cache:
            if bp.name == name:
                return bp
        return None
    
    def filter_blueprints(self, search_term: str = "", 
                         min_light_armor: int = 0) -> List[BlueprintInfo]:
        """
        Filter cached blueprints by search term and minimum light armor count.
        
        Args:
            search_term: Search in blueprint name/display name
            min_light_armor: Minimum number of light armor blocks
        
        Returns:
            Filtered list of BlueprintInfo objects
        """
        filtered = []
        search_lower = search_term.lower()
        
        for bp in self.blueprints_cache:
            if bp.light_armor_count < min_light_armor:
                continue
            
            if search_term and search_lower not in bp.name.lower() and \
               search_lower not in bp.display_name.lower():
                continue
            
            filtered.append(bp)
        
        return filtered
```

---

### 7. Updated `gui_standalone.py` — Icon loading + custom directory picker + batch conversion + dry-run preview

```python
"""
Space Engineers Block Exchanger - Standalone Desktop Application
Tactical Command Center GUI using tkinter
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from tkinter import filedialog
import threading
from typing import Optional, List
import sys
import os

from blueprint_scanner import BlueprintScanner, BlueprintInfo
from blueprint_converter import BlueprintConverter
from se_armor_replacer import ArmorBlockReplacer


def get_resource_path(filename: str) -> str:
    """Get absolute path to a resource, works for dev and PyInstaller."""
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, filename)


class TacticalTheme:
    """Tactical hologram color scheme and styling constants."""
    
    # Colors
    BG_DARK = "#0f172a"           # Deep gunmetal
    BG_MEDIUM = "#1e293b"         # Medium slate
    BG_GLASS = "#1a2332"          # Tech-glass
    CYAN_PRIMARY = "#06b6d4"      # Neon cyan
    CYAN_DIM = "#0891b2"          # Dimmed cyan
    ORANGE_PRIMARY = "#f59e0b"    # Industrial orange
    ORANGE_DIM = "#d97706"        # Dimmed orange
    GREEN_PRIMARY = "#22c55e"     # Success green
    TEXT_CYAN = "#67e8f9"         # Light cyan text
    TEXT_GRAY = "#94a3b8"         # Gray text
    BORDER_CYAN = "#22d3ee"       # Cyan border
    BORDER_ORANGE = "#fb923c"     # Orange border
    
    # Font
    FONT_FAMILY = "Courier New"   # Monospace
    FONT_SMALL = ("Courier New", 9)
    FONT_NORMAL = ("Courier New", 10)
    FONT_LARGE = ("Courier New", 12, "bold")
    FONT_TITLE = ("Courier New", 14, "bold")


class TacticalCommandCenter(tk.Tk):
    """Main application window with tactical hologram interface."""
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("SE BLOCK EXCHANGER // TACTICAL COMMAND CENTER")
        self.geometry("1200x800")
        self.configure(bg=TacticalTheme.BG_DARK)
        
        # Set window icon
        self._set_icon()
        
        # Initialize services
        self.scanner = BlueprintScanner()
        self.conversion_mode = "light_to_heavy"  # or "heavy_to_light"
        self.converter = BlueprintConverter(verbose=True, reverse=False)
        self.selected_blueprint: Optional[BlueprintInfo] = None
        self.blueprints = []
        self.custom_blueprint_dir: Optional[str] = None
        
        # Build UI
        self.create_widgets()
        
        # Load blueprints
        self.after(100, self.load_blueprints_async)
        
        # Center window
        self.center_window()

    def _set_icon(self):
        """Set the application window icon."""
        try:
            icon_path = get_resource_path('app_icon.ico')
            if os.path.exists(icon_path):
                self.iconbitmap(icon_path)
        except Exception:
            pass  # Icon is cosmetic; don't crash if missing
        
    def center_window(self):
        """Center the window on screen."""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f'{width}x{height}+{x}+{y}')
```

